#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "msg.h"
#include "track.h"

#define BLOCK_SECTORS 16

struct track *first_track = NULL, *last_track = NULL;

static const uint32_t edctable[] = {
  0x00000000UL,0x90910101UL,0x91210201UL,0x01b00300UL,
  0x92410401UL,0x02d00500UL,0x03600600UL,0x93f10701UL,
  0x94810801UL,0x04100900UL,0x05a00a00UL,0x95310b01UL,
  0x06c00c00UL,0x96510d01UL,0x97e10e01UL,0x07700f00UL,
  0x99011001UL,0x09901100UL,0x08201200UL,0x98b11301UL,
  0x0b401400UL,0x9bd11501UL,0x9a611601UL,0x0af01700UL,
  0x0d801800UL,0x9d111901UL,0x9ca11a01UL,0x0c301b00UL,
  0x9fc11c01UL,0x0f501d00UL,0x0ee01e00UL,0x9e711f01UL,
  0x82012001UL,0x12902100UL,0x13202200UL,0x83b12301UL,
  0x10402400UL,0x80d12501UL,0x81612601UL,0x11f02700UL,
  0x16802800UL,0x86112901UL,0x87a12a01UL,0x17302b00UL,
  0x84c12c01UL,0x14502d00UL,0x15e02e00UL,0x85712f01UL,
  0x1b003000UL,0x8b913101UL,0x8a213201UL,0x1ab03300UL,
  0x89413401UL,0x19d03500UL,0x18603600UL,0x88f13701UL,
  0x8f813801UL,0x1f103900UL,0x1ea03a00UL,0x8e313b01UL,
  0x1dc03c00UL,0x8d513d01UL,0x8ce13e01UL,0x1c703f00UL,
  0xb4014001UL,0x24904100UL,0x25204200UL,0xb5b14301UL,
  0x26404400UL,0xb6d14501UL,0xb7614601UL,0x27f04700UL,
  0x20804800UL,0xb0114901UL,0xb1a14a01UL,0x21304b00UL,
  0xb2c14c01UL,0x22504d00UL,0x23e04e00UL,0xb3714f01UL,
  0x2d005000UL,0xbd915101UL,0xbc215201UL,0x2cb05300UL,
  0xbf415401UL,0x2fd05500UL,0x2e605600UL,0xbef15701UL,
  0xb9815801UL,0x29105900UL,0x28a05a00UL,0xb8315b01UL,
  0x2bc05c00UL,0xbb515d01UL,0xbae15e01UL,0x2a705f00UL,
  0x36006000UL,0xa6916101UL,0xa7216201UL,0x37b06300UL,
  0xa4416401UL,0x34d06500UL,0x35606600UL,0xa5f16701UL,
  0xa2816801UL,0x32106900UL,0x33a06a00UL,0xa3316b01UL,
  0x30c06c00UL,0xa0516d01UL,0xa1e16e01UL,0x31706f00UL,
  0xaf017001UL,0x3f907100UL,0x3e207200UL,0xaeb17301UL,
  0x3d407400UL,0xadd17501UL,0xac617601UL,0x3cf07700UL,
  0x3b807800UL,0xab117901UL,0xaaa17a01UL,0x3a307b00UL,
  0xa9c17c01UL,0x39507d00UL,0x38e07e00UL,0xa8717f01UL,
  0xd8018001UL,0x48908100UL,0x49208200UL,0xd9b18301UL,
  0x4a408400UL,0xdad18501UL,0xdb618601UL,0x4bf08700UL,
  0x4c808800UL,0xdc118901UL,0xdda18a01UL,0x4d308b00UL,
  0xdec18c01UL,0x4e508d00UL,0x4fe08e00UL,0xdf718f01UL,
  0x41009000UL,0xd1919101UL,0xd0219201UL,0x40b09300UL,
  0xd3419401UL,0x43d09500UL,0x42609600UL,0xd2f19701UL,
  0xd5819801UL,0x45109900UL,0x44a09a00UL,0xd4319b01UL,
  0x47c09c00UL,0xd7519d01UL,0xd6e19e01UL,0x46709f00UL,
  0x5a00a000UL,0xca91a101UL,0xcb21a201UL,0x5bb0a300UL,
  0xc841a401UL,0x58d0a500UL,0x5960a600UL,0xc9f1a701UL,
  0xce81a801UL,0x5e10a900UL,0x5fa0aa00UL,0xcf31ab01UL,
  0x5cc0ac00UL,0xcc51ad01UL,0xcde1ae01UL,0x5d70af00UL,
  0xc301b001UL,0x5390b100UL,0x5220b200UL,0xc2b1b301UL,
  0x5140b400UL,0xc1d1b501UL,0xc061b601UL,0x50f0b700UL,
  0x5780b800UL,0xc711b901UL,0xc6a1ba01UL,0x5630bb00UL,
  0xc5c1bc01UL,0x5550bd00UL,0x54e0be00UL,0xc471bf01UL,
  0x6c00c000UL,0xfc91c101UL,0xfd21c201UL,0x6db0c300UL,
  0xfe41c401UL,0x6ed0c500UL,0x6f60c600UL,0xfff1c701UL,
  0xf881c801UL,0x6810c900UL,0x69a0ca00UL,0xf931cb01UL,
  0x6ac0cc00UL,0xfa51cd01UL,0xfbe1ce01UL,0x6b70cf00UL,
  0xf501d001UL,0x6590d100UL,0x6420d200UL,0xf4b1d301UL,
  0x6740d400UL,0xf7d1d501UL,0xf661d601UL,0x66f0d700UL,
  0x6180d800UL,0xf111d901UL,0xf0a1da01UL,0x6030db00UL,
  0xf3c1dc01UL,0x6350dd00UL,0x62e0de00UL,0xf271df01UL,
  0xee01e001UL,0x7e90e100UL,0x7f20e200UL,0xefb1e301UL,
  0x7c40e400UL,0xecd1e501UL,0xed61e601UL,0x7df0e700UL,
  0x7a80e800UL,0xea11e901UL,0xeba1ea01UL,0x7b30eb00UL,
  0xe8c1ec01UL,0x7850ed00UL,0x79e0ee00UL,0xe971ef01UL,
  0x7700f000UL,0xe791f101UL,0xe621f201UL,0x76b0f300UL,
  0xe541f401UL,0x75d0f500UL,0x7460f600UL,0xe4f1f701UL,
  0xe381f801UL,0x7310f900UL,0x72a0fa00UL,0xe231fb01UL,
  0x71c0fc00UL,0xe151fd01UL,0xe0e1fe01UL,0x7070ff00UL,
};

static const uint8_t rs_l12_log[] = {
  0x00,0x00,0x01,0x19,0x02,0x32,0x1a,0xc6,
  0x03,0xdf,0x33,0xee,0x1b,0x68,0xc7,0x4b,
  0x04,0x64,0xe0,0x0e,0x34,0x8d,0xef,0x81,
  0x1c,0xc1,0x69,0xf8,0xc8,0x08,0x4c,0x71,
  0x05,0x8a,0x65,0x2f,0xe1,0x24,0x0f,0x21,
  0x35,0x93,0x8e,0xda,0xf0,0x12,0x82,0x45,
  0x1d,0xb5,0xc2,0x7d,0x6a,0x27,0xf9,0xb9,
  0xc9,0x9a,0x09,0x78,0x4d,0xe4,0x72,0xa6,
  0x06,0xbf,0x8b,0x62,0x66,0xdd,0x30,0xfd,
  0xe2,0x98,0x25,0xb3,0x10,0x91,0x22,0x88,
  0x36,0xd0,0x94,0xce,0x8f,0x96,0xdb,0xbd,
  0xf1,0xd2,0x13,0x5c,0x83,0x38,0x46,0x40,
  0x1e,0x42,0xb6,0xa3,0xc3,0x48,0x7e,0x6e,
  0x6b,0x3a,0x28,0x54,0xfa,0x85,0xba,0x3d,
  0xca,0x5e,0x9b,0x9f,0x0a,0x15,0x79,0x2b,
  0x4e,0xd4,0xe5,0xac,0x73,0xf3,0xa7,0x57,
  0x07,0x70,0xc0,0xf7,0x8c,0x80,0x63,0x0d,
  0x67,0x4a,0xde,0xed,0x31,0xc5,0xfe,0x18,
  0xe3,0xa5,0x99,0x77,0x26,0xb8,0xb4,0x7c,
  0x11,0x44,0x92,0xd9,0x23,0x20,0x89,0x2e,
  0x37,0x3f,0xd1,0x5b,0x95,0xbc,0xcf,0xcd,
  0x90,0x87,0x97,0xb2,0xdc,0xfc,0xbe,0x61,
  0xf2,0x56,0xd3,0xab,0x14,0x2a,0x5d,0x9e,
  0x84,0x3c,0x39,0x53,0x47,0x6d,0x41,0xa2,
  0x1f,0x2d,0x43,0xd8,0xb7,0x7b,0xa4,0x76,
  0xc4,0x17,0x49,0xec,0x7f,0x0c,0x6f,0xf6,
  0x6c,0xa1,0x3b,0x52,0x29,0x9d,0x55,0xaa,
  0xfb,0x60,0x86,0xb1,0xbb,0xcc,0x3e,0x5a,
  0xcb,0x59,0x5f,0xb0,0x9c,0xa9,0xa0,0x51,
  0x0b,0xf5,0x16,0xeb,0x7a,0x75,0x2c,0xd7,
  0x4f,0xae,0xd5,0xe9,0xe6,0xe7,0xad,0xe8,
  0x74,0xd6,0xf4,0xea,0xa8,0x50,0x58,0xaf,
};

static const uint8_t rs_l12_alog[] = {
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
  0x1d,0x3a,0x74,0xe8,0xcd,0x87,0x13,0x26,
  0x4c,0x98,0x2d,0x5a,0xb4,0x75,0xea,0xc9,
  0x8f,0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,
  0x9d,0x27,0x4e,0x9c,0x25,0x4a,0x94,0x35,
  0x6a,0xd4,0xb5,0x77,0xee,0xc1,0x9f,0x23,
  0x46,0x8c,0x05,0x0a,0x14,0x28,0x50,0xa0,
  0x5d,0xba,0x69,0xd2,0xb9,0x6f,0xde,0xa1,
  0x5f,0xbe,0x61,0xc2,0x99,0x2f,0x5e,0xbc,
  0x65,0xca,0x89,0x0f,0x1e,0x3c,0x78,0xf0,
  0xfd,0xe7,0xd3,0xbb,0x6b,0xd6,0xb1,0x7f,
  0xfe,0xe1,0xdf,0xa3,0x5b,0xb6,0x71,0xe2,
  0xd9,0xaf,0x43,0x86,0x11,0x22,0x44,0x88,
  0x0d,0x1a,0x34,0x68,0xd0,0xbd,0x67,0xce,
  0x81,0x1f,0x3e,0x7c,0xf8,0xed,0xc7,0x93,
  0x3b,0x76,0xec,0xc5,0x97,0x33,0x66,0xcc,
  0x85,0x17,0x2e,0x5c,0xb8,0x6d,0xda,0xa9,
  0x4f,0x9e,0x21,0x42,0x84,0x15,0x2a,0x54,
  0xa8,0x4d,0x9a,0x29,0x52,0xa4,0x55,0xaa,
  0x49,0x92,0x39,0x72,0xe4,0xd5,0xb7,0x73,
  0xe6,0xd1,0xbf,0x63,0xc6,0x91,0x3f,0x7e,
  0xfc,0xe5,0xd7,0xb3,0x7b,0xf6,0xf1,0xff,
  0xe3,0xdb,0xab,0x4b,0x96,0x31,0x62,0xc4,
  0x95,0x37,0x6e,0xdc,0xa5,0x57,0xae,0x41,
  0x82,0x19,0x32,0x64,0xc8,0x8d,0x07,0x0e,
  0x1c,0x38,0x70,0xe0,0xdd,0xa7,0x53,0xa6,
  0x51,0xa2,0x59,0xb2,0x79,0xf2,0xf9,0xef,
  0xc3,0x9b,0x2b,0x56,0xac,0x45,0x8a,0x09,
  0x12,0x24,0x48,0x90,0x3d,0x7a,0xf4,0xf5,
  0xf7,0xf3,0xfb,0xeb,0xcb,0x8b,0x0b,0x16,
  0x2c,0x58,0xb0,0x7d,0xfa,0xe9,0xcf,0x83,
  0x1b,0x36,0x6c,0xd8,0xad,0x47,0x8e,0x01,
  0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1d,
  0x3a,0x74,0xe8,0xcd,0x87,0x13,0x26,0x4c,
  0x98,0x2d,0x5a,0xb4,0x75,0xea,0xc9,0x8f,
  0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,0x9d,
  0x27,0x4e,0x9c,0x25,0x4a,0x94,0x35,0x6a,
  0xd4,0xb5,0x77,0xee,0xc1,0x9f,0x23,0x46,
  0x8c,0x05,0x0a,0x14,0x28,0x50,0xa0,0x5d,
  0xba,0x69,0xd2,0xb9,0x6f,0xde,0xa1,0x5f,
  0xbe,0x61,0xc2,0x99,0x2f,0x5e,0xbc,0x65,
  0xca,0x89,0x0f,0x1e,0x3c,0x78,0xf0,0xfd,
  0xe7,0xd3,0xbb,0x6b,0xd6,0xb1,0x7f,0xfe,
  0xe1,0xdf,0xa3,0x5b,0xb6,0x71,0xe2,0xd9,
  0xaf,0x43,0x86,0x11,0x22,0x44,0x88,0x0d,
  0x1a,0x34,0x68,0xd0,0xbd,0x67,0xce,0x81,
  0x1f,0x3e,0x7c,0xf8,0xed,0xc7,0x93,0x3b,
  0x76,0xec,0xc5,0x97,0x33,0x66,0xcc,0x85,
  0x17,0x2e,0x5c,0xb8,0x6d,0xda,0xa9,0x4f,
  0x9e,0x21,0x42,0x84,0x15,0x2a,0x54,0xa8,
  0x4d,0x9a,0x29,0x52,0xa4,0x55,0xaa,0x49,
  0x92,0x39,0x72,0xe4,0xd5,0xb7,0x73,0xe6,
  0xd1,0xbf,0x63,0xc6,0x91,0x3f,0x7e,0xfc,
  0xe5,0xd7,0xb3,0x7b,0xf6,0xf1,0xff,0xe3,
  0xdb,0xab,0x4b,0x96,0x31,0x62,0xc4,0x95,
  0x37,0x6e,0xdc,0xa5,0x57,0xae,0x41,0x82,
  0x19,0x32,0x64,0xc8,0x8d,0x07,0x0e,0x1c,
  0x38,0x70,0xe0,0xdd,0xa7,0x53,0xa6,0x51,
  0xa2,0x59,0xb2,0x79,0xf2,0xf9,0xef,0xc3,
  0x9b,0x2b,0x56,0xac,0x45,0x8a,0x09,0x12,
  0x24,0x48,0x90,0x3d,0x7a,0xf4,0xf5,0xf7,
  0xf3,0xfb,0xeb,0xcb,0x8b,0x0b,0x16,0x2c,
  0x58,0xb0,0x7d,0xfa,0xe9,0xcf,0x83,0x1b,
  0x36,0x6c,0xd8,0xad,0x47,0x8e,
};

static const uint8_t DP0[] = {
  231,229,171,210,240,17,67,215,43,120,8,199,74,102,220,251,95,175,
  87,166,113,75,198,25,0
};
static const uint8_t DP1[] = {
  230,172,211,241,18,68,216,44,121,9,200,75,103,221,252,96,176,88,
  167,114,76,199,26,1,0
};
static const uint8_t DQ0[] = {
  190,96,250,132,59,81,159,154,200,7,111,245,10,20,41,156,168,79,173,
  231,229,171,210,240,17,67,215,43,120,8,199,74,102,220,251,95,175,
  87,166,113,75,198,25,0
};
static const uint8_t DQ1[] = {
  97,251,133,60,82,160,155,201,8,112,246,11,21,42,157,169,80,174,232,
  230,172,211,241,18,68,216,44,121,9,200,75,103,221,252,96,176,88,
  167,114,76,199,26,1,0
};

static void encode_P(const uint8_t *data, unsigned sz, uint8_t *P)
{
  unsigned i=0, j=0, n;
  memset(P, 0, 43*2*2);
  unsigned dp0 = DP0[0], dp1 = DP1[0];
  for (n=0; n<sz; n++) {
    if (data[n]) {
      int base = rs_l12_log[data[n]];
      P[j] ^= rs_l12_alog[base + dp0];
      P[j+43*2] ^= rs_l12_alog[base + dp1];
    }
    if (++j == 2*43) { j=0; ++i; dp0 = DP0[i]; dp1 = DP1[i]; }
  }
}

static void encode_Q(const uint8_t *data, unsigned sz, uint8_t *Q)
{
  int i=0, j=0;
  unsigned n;
  memset(Q, 0, 26*2*2);
  int dq0 = DQ0[0], dq1 = DQ1[0];
  for (n=0; n<sz; n++) {
    if (data[n]) {
      unsigned base = rs_l12_log[data[n]];
      Q[j] ^= rs_l12_alog[base + dq0];
      Q[j+26*2] ^= rs_l12_alog[base + dq1];
    }
    if (j&1) {
      if (++i == 43)
	{ i = 0; j -= 16; }
      if ((j-=3)<0)
	j += 52;
      dq0 = DQ0[i]; dq1 = DQ1[i];
    } else j++;
  }
}

static void add_edc(const uint8_t *data, unsigned sz, uint8_t *EDC)
{
  uint32_t r = 0;
  unsigned n;
  for (n=0; n<sz; n++) {
    uint8_t v = data[n] ^ (r & 0xff);
    r = (r >> 8) ^ edctable[v];
  }
  EDC[0] = r&0xff;
  EDC[1] = (r>>8)&0xff;
  EDC[2] = (r>>16)&0xff;
  EDC[3] = (r>>24)&0xff;
}

static void add_ecc(uint8_t *sector)
{
  encode_P(sector+12, 2064, sector+2076);
  encode_Q(sector+12, 2236, sector+2248);
}

static uint8_t to_bcd(uint8_t n)
{
  return ((n/10)<<4)+(n%10);
}

static void adr_to_msf_bcd(uint32_t adr, uint8_t *msf)
{
  uint8_t m = adr / 4500;
  uint8_t s = (adr % 4500) / 75;
  uint8_t f = adr % 75;
  msf[0] = to_bcd(m);
  msf[1] = to_bcd(s);
  msf[2] = to_bcd(f);
}

static void add_header(uint8_t *sector, uint32_t adr, uint8_t mode)
{
  memset(sector, 0, 16);
  memset(sector+1, 0xff, 10);
  adr_to_msf_bcd(adr, sector+12);
  sector[15] = mode;
}

static void add_xa_subheader(uint8_t *sector)
{
  sector[16] = 0; /* File number */
  sector[17] = 0; /* Channel number */
  sector[18] = 8; /* Submode (Data) */
  sector[19] = 0; /* Data type */
  memcpy(sector+20, sector+16, 4);
}

void convert_track_swap_2352(uint8_t *sector, uint32_t adr)
{
  for(unsigned i = 0; i < 2352; i+=2) {
    uint8_t t = sector[i];
    sector[i] = sector[i+1];
    sector[i+1] = t;
  }
}

void convert_track_mode_1_2048(uint8_t *sector, uint32_t adr)
{
  add_header(sector, adr, 1);
  add_edc(sector, 16+2048, sector+2064);
  memset(sector+2068, 0, 8);
  add_ecc(sector);
}

void convert_track_mode_2_2336(uint8_t *sector, uint32_t adr)
{
  add_header(sector, adr, 2);
}

void convert_track_xa_form_1_2048(uint8_t *sector, uint32_t adr)
{
  add_header(sector, 0, 0); /* Fake header for ECC calculations */
  add_xa_subheader(sector);
  add_edc(sector+16, 8+2048, sector+2072);
  add_ecc(sector);
  add_header(sector, adr, 2);
}

void convert_track_xa_form_1_2056(uint8_t *sector, uint32_t adr)
{
  add_header(sector, 0, 0); /* Fake header for ECC calculations */
  add_edc(sector+16, 8+2048, sector+2072);
  add_ecc(sector);
  add_header(sector, adr, 2);
}

void convert_track_xa_form_2_2324(uint8_t *sector, uint32_t adr)
{
  add_header(sector, adr, 2);
  add_xa_subheader(sector);
  add_edc(sector+16, 8+2324, sector+2348);
}

void convert_track_xa_form_2_2332(uint8_t *sector, uint32_t adr)
{
  add_header(sector, adr, 2);
  add_edc(sector+16, 8+2324, sector+2348);
}

static const struct {
  uint32_t input_size;
  uint32_t input_offs;
  void (*convert_func)(uint8_t *, uint32_t);
} formats[] = {
  [ TRACK_RAW_2352 ] = { 2352, 0, NULL },
  [ TRACK_SWAP_2352 ] = { 2352, 0, convert_track_swap_2352 },
  [ TRACK_MODE_1_2048 ] = { 2048, 16, convert_track_mode_1_2048 },
  [ TRACK_MODE_2_2336 ] = { 2336, 16, convert_track_mode_2_2336 },
  [ TRACK_XA_FORM_1_2048 ] = { 2048, 24, convert_track_xa_form_1_2048 },
  [ TRACK_XA_FORM_1_2056 ] = { 2056, 16, convert_track_xa_form_1_2056 },
  [ TRACK_XA_FORM_2_2324 ] = { 2324, 24, convert_track_xa_form_2_2324 },
  [ TRACK_XA_FORM_2_2332 ] = { 2332, 16, convert_track_xa_form_2_2332 },
};

static bool track_validate_size(enum track_type type, uint32_t secsize)
{
  if (type == TRACK_RAW_2352 && secsize >= 2352)
    /* Allow extra (subchannel) data */
    return true;

  if (secsize != formats[type].input_size) {
    msg_error("Invalid sector size (%u != %u) in input\n",
	      (unsigned)secsize, (unsigned)formats[type].input_size);
    return false;
  }

  return true;
}

static bool track_read_sector(struct track *t, uint8_t *sector, FILE *f,
			      uint32_t adr)
{
  if (f == NULL)
    memset(sector, 0, 2352);
  if (t->type == TRACK_RAW_2352) {
    if (f != NULL) {
      size_t r = fread(sector, 1, 2352, f);
      if (r != 2352) {
	msg_error("Incomplete read from input file\n");
	return false;
      }
      if (t->data_size > 2352) {
	if (fseek(f, t->data_size-2352, SEEK_CUR) < 0) {
	  msg_error("Failed to seek in input file\n");
	  return false;
	}
      }
    }
  } else {
    if (f != NULL) {
      size_t r = fread(sector+formats[t->type].input_offs, 1,
		       formats[t->type].input_size, f);
      if (r != formats[t->type].input_size) {
	msg_error("Incomplete read from input file\n");
	return false;
      }
    }
    formats[t->type].convert_func(sector, adr);
  }
  return true;
}

struct track *track_create(void)
{
  struct track *t = calloc(1, sizeof(struct track));
  if (!t) {
    msg_oom();
    return NULL;
  }
  t->next = NULL;
  t->data_file = NULL;
  t->data_filename = NULL;
  if (last_track)
    last_track->next = t;
  else
    first_track = t;
  last_track = t;
  return t;
}

void track_delete_all()
{
  while(first_track) {
    struct track *t = first_track;
    first_track = t->next;
    if (t->data_filename)
      free(t->data_filename);
    free(t);
  }
  last_track = NULL;
}

struct track *track_get_first()
{
  return first_track;
}

bool track_data_from_filename(struct track *t, enum track_type type, uint32_t secsize, const char *filename, uint32_t offset, uint32_t count)
{
  if (!t || t->data_file || t->data_filename) {
    msg_error("Invalid track passed to track_data_from_filename\n");
    return false;
  }
  if (!track_validate_size(type, secsize))
    return false;
  char *filename_copy = malloc(strlen(filename)+1);
  if (!filename_copy) {
    msg_oom();
    return false;
  }
  strcpy(filename_copy, filename);
  t->type = type;
  t->data_size = secsize;
  t->data_offs = offset;
  t->data_filename = filename_copy;
  if (count == TRACK_SECTOR_COUNT_PROBE) {
    FILE *f = fopen(filename_copy, "rb");
    if (!f) {
      msg_perror(filename_copy);
      return false;
    }
    long flen = -1;
    if (fseek(f, 0, SEEK_END) >= 0)
      flen = ftell(f);
    fclose(f);
    if (flen < 0) {
      msg_perror(filename_copy);
      return false;
    }
    if (flen < (long)offset) {
      msg_error("File offset is beyond EOF\n");
      return false;
    }
    t->data_count = (flen - (long)offset) / (long)secsize;
  } else
    t->data_count = count;
  return true;
}

bool track_data_from_file(struct track *t, enum track_type type, uint32_t secsize, FILE *file, uint32_t offset, uint32_t count)
{
  if (!t || t->data_file || t->data_filename) {
    msg_error("Invalid track passed to track_data_from_file\n");
    return false;
  }
  if (!track_validate_size(type, secsize))
    return false;
  t->type = type;
  t->data_size = secsize;
  t->data_offs = offset;
  t->data_file = file;
  if (count == TRACK_SECTOR_COUNT_PROBE) {
    msg_error("Invalid sector count passed to track_data_from_file\n");
    return false;
  } else
    t->data_count = count;
  return true;
}

bool track_convert(struct track *t, FILE *f)
{
  uint8_t (*sector)[BLOCK_SECTORS][2352];
  if (!(sector = malloc(sizeof(*sector)))) {
    msg_oom();
    return false;
  }
  FILE *df = NULL;
  bool do_close = false;
  if (t->data_filename) {
    do_close = true;
    df = fopen(t->data_filename, "rb");
    if (!df) {
      msg_perror(t->data_filename);
      free(sector);
      return false;
    }
  } else
    df = t->data_file;
  if (df && fseek(df, t->data_offs, SEEK_SET) < 0) {
    msg_error("Failed to seek in input file\n");
    free(sector);
    if (do_close)
      fclose(df);
    return false;
  }
  msg_progress_start_nr(t->track_nr);
  for (uint32_t n = 0; n < t->data_count; n += BLOCK_SECTORS) {
    msg_progress_update(n, t->data_count);
    uint32_t cnt = (t->data_count - n > BLOCK_SECTORS ?
		    BLOCK_SECTORS : t->data_count - n);
    for (uint32_t n2 = 0; n2 < cnt; n2++)
      if (!track_read_sector(t, (*sector)[n2], df, t->start_sector+n+n2)) {
	free(sector);
	if (do_close)
	  fclose(df);
	return false;
      }
    if (fwrite(&(*sector)[0][0], 2352, cnt, f) != cnt) {
      msg_error("Failed to write to output file\n");
      free(sector);
      if (do_close)
	fclose(df);
      return false;
    }
  }
  msg_progress_update(t->data_count, t->data_count);
  free(sector);
  if (do_close)
    fclose(df);
  return true;
}
